<<<<<<< HEAD
let Promise = global.Promise;
=======
'use strict';

var Promise = global.Promise;
>>>>>>> ab1ca82485e1b8ef397328128ced844cc70c2f76

/// encapsulate a method with a node-style callback in a Promise
/// @param {object} 'this' of the encapsulated function
/// @param {function} function to be encapsulated
/// @param {Array-like} args to be passed to the called function
/// @return {Promise} a Promise encapsulating the function
<<<<<<< HEAD
function promise(fn, context, args) {
=======
module.exports.promise = function (fn, context, args) {

>>>>>>> ab1ca82485e1b8ef397328128ced844cc70c2f76
    if (!Array.isArray(args)) {
        args = Array.prototype.slice.call(args);
    }

    if (typeof fn !== 'function') {
        return Promise.reject(new Error('fn must be a function'));
    }

<<<<<<< HEAD
    return new Promise((resolve, reject) => {
        args.push((err, data) => {
=======
    return new Promise(function(resolve, reject) {
        args.push(function(err, data) {
>>>>>>> ab1ca82485e1b8ef397328128ced844cc70c2f76
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });

        fn.apply(context, args);
    });
<<<<<<< HEAD
}

/// @param {err} the error to be thrown
function reject(err) {
    return Promise.reject(err);
}

/// changes the promise implementation that bcrypt uses
/// @param {Promise} the implementation to use
function use(promise) {
    Promise = promise;
}

module.exports = {
    promise,
    reject,
    use
}
=======
};

/// @param {err} the error to be thrown
module.exports.reject = function (err) {
    return Promise.reject(err);
};

/// changes the promise implementation that bcrypt uses
/// @param {Promise} the implementation to use
module.exports.use = function(promise) {
  Promise = promise;
};
>>>>>>> ab1ca82485e1b8ef397328128ced844cc70c2f76
